{
    "collab_server" : "",
    "contents" : "# 特徴量を加工する\n\n# 初期化\nrm(list = ls())\ngc();gc()\n\n# パッケージ\nrequire(data.table)\nrequire(dplyr)\nrequire(xgboost)\nrequire(caret)\nrequire(tcltk)\n\n# データ加工----\n# データ読み込み\ndata.train.raw <- fread(\"inputs/train.csv\", data.table = F, stringsAsFactors = T)\ndata.test.raw <- fread(\"inputs/test.csv\", data.table = F, stringsAsFactors = T)\n# あとでデータを分割するために、行数を取得しておく\nn.train <- nrow(data.train.raw)\nn.test <- nrow(data.test.raw)\n# train, testをくっつける\ndata.full <- bind_rows(data.train.raw, data.test.raw)\n\n# 特徴量加工\n# 敬称\ndata.full$Title <- gsub('(.*, )|(\\\\..*)', '', data.full$Name)\nrare_title <- c('Dona', 'Lady', 'the Countess','Capt', 'Col', 'Don', \n                'Dr', 'Major', 'Rev', 'Sir', 'Jonkheer')\ndata.full$Title[data.full$Title == 'Mlle']        <- 'Miss' \ndata.full$Title[data.full$Title == 'Ms']          <- 'Miss'\ndata.full$Title[data.full$Title == 'Mme']         <- 'Mrs' \ndata.full$Title[data.full$Title %in% rare_title]  <- 'Rare Title'\n# 家族の名字\ndata.full$Surname <- sapply(data.full$Name,  \n                            function(x) strsplit(x, split = '[,.]')[[1]][1])\n# 掛け算変数\ndata.full$Pclass_Age <- data.full$Pclass * data.full$Age\ndata.full$Pclass_SibSp <- data.full$Pclass * data.full$SibSp\ndata.full$Pclass_Parch <- data.full$Pclass * data.full$Parch\ndata.full$Pclass_Fare <- data.full$Pclass * data.full$Fare\ndata.full$Age_SibSp <- data.full$Age * data.full$SibSp\ndata.full$Age_Parch <- data.full$Age * data.full$Parch\ndata.full$Age_Fare <- data.full$Age * data.full$Fare\ndata.full$SibSp_Parch <- data.full$SibSp * data.full$Parch\ndata.full$SibSp_Fare <- data.full$SibSp * data.full$Fare\ndata.full$Parch_Fare <- data.full$Pclass * data.full$Fare\n\n# # 家族について\ndata.full$Fsize <- data.full$SibSp + data.full$Parch + 1\ndata.full$Family <- paste(data.full$Surname, data.full$Fsize, sep='_')\ndata.full$FsizeD[data.full$Fsize == 1] <- 'singleton'\ndata.full$FsizeD[data.full$Fsize < 5 & data.full$Fsize > 1] <- 'small'\ndata.full$FsizeD[data.full$Fsize > 4] <- 'large'\n# # 居室\ndata.full$Deck <- sapply(data.full$Cabin, function(x) strsplit(x, NULL)[[1]][1])\n# # 人の属性など\ndata.full$Child[data.full$Age < 18] <- 'Child'\ndata.full$Child[data.full$Age >= 18] <- 'Adult'\ndata.full$Child[data.full$Age < 5] <- 'Baby'\ndata.full$Mother <- 'Not Mother'\ndata.full$Mother[data.full$Sex == 'female' & data.full$Parch > 0 & data.full$Age > 18 & data.full$Title != 'Miss'] <- 'Mother'\ndata.full$femaleChild <- ifelse(data.full %>% select(Sex) == \"female\" | data.full %>% select(Age) < 10, yes = 1, no = 0 ) %>% as.vector()\ndata.full$maleAdult <- ifelse(data.full %>% select(Sex) == \"male\" & (data.full %>% select(Age) > 20 & data.full %>% select(Age) < 35), yes = 1, no = 0 ) %>% as.vector()\ndata.full$Pclass_char <- data.full$Pclass %>% paste0(\"A\")\n# チケット番号\nvector_ticket <- data.full$Ticket\n\n# チケット番号\ntic_num <- vector(length = length(vector_ticket))\ntic_char <- vector(length = length(vector_ticket))\nfor(i in 1 : length(vector_ticket)){\n  temp.tic <- strsplit(vector_ticket[i], \"\\\\s\") %>% unlist()\n  if(length(temp.tic) >= 1){\n    for(j in 1 : length(temp.tic)){\n      if(is.na(as.numeric(temp.tic[j]))){\n        tic_char[i] <- temp.tic[j]\n      }else{\n        tic_num[i] <- as.numeric(temp.tic[j])\n      }\n    }\n  }else{\n    tic_num[i] <- NA\n    tic_char[i] <- NA\n  }\n}\ndata.full$tic_num <- tic_num\ndata.full$tic_char <- tic_char\ntable(data.full %>% select(Survived, tic_char))\ndata.full$tic_char[data.full$tic_char %in% c('A./5.', 'A.5.', 'A/5', 'A/5.')] <- 'A5'\ndata.full$tic_char[data.full$tic_char %in% c('A/4', 'A/4.', 'A4.')] <- 'A4'\ndata.full$tic_char[data.full$tic_char %in% c('C.A.', 'CA.', 'A4.')] <- 'CA'\ndata.full$tic_char[data.full$tic_char %in% c('F.C.', 'F.C.C.')] <- 'FC'\ndata.full$tic_char[data.full$tic_char %in% c('SC/Paris', 'SC/PARIS', 'S.C./PARIS')] <- 'SCPARIS'\ndata.full$tic_char[data.full$tic_char %in% c('S.C./A.4.', 'SC/A4')] <- 'SCA4'\ndata.full$tic_char[data.full$tic_char %in% c('W/C', 'W./C.')] <- 'WC'\ndata.full$tic_char[data.full$tic_char %in% c('WE/P', 'W.E.P.')] <- 'WEP'\ndata.full$tic_char[data.full$tic_char %in% c('SOTON/O2', 'STON/O2.')] <- 'SOTONO2'\ndata.full$tic_char[data.full$tic_char %in% c('SOTON/O.Q.', 'SOTON/OQ', 'STON/OQ.')] <- 'SOTONOQ'\n# キャビン関係\ncabin_n <- c(NA, length = dim(data.full)[1])\ncabin_class_first <- c(NA, length = dim(data.full)[1])\ncabin_class_second <- c(NA, length = dim(data.full)[1])\ncabin_num <- c(NA, length = dim(data.full)[1])\nfor(i in 1 : dim(data.full)[1]){\n  temp_cabin <- strsplit(data.full$Cabin[i], \"\\\\s\") %>% unlist()\n  cabin_n[i] <- length(temp_cabin)\n  if(length(temp_cabin) != 0){\n    cabin_class_first[i] <- gsub(pattern = \"[0-9]\",replacement = \"\",temp_cabin) %>% head(1)\n    cabin_class_second[i] <- gsub(pattern = \"[0-9]\",replacement = \"\",temp_cabin) %>% tail(1)\n    cabin_num[i] <- gsub(pattern = \"[A-Z]\",replacement = \"\",temp_cabin) %>% as.numeric() %>% mean()\n  }else{\n    cabin_class_first[i] <- NA\n    cabin_class_second[i] <- NA\n    cabin_num[i] <- NA\n  }\n}\ndata.full$cabin_n <- cabin_n\ndata.full$cabin_num <- cabin_num\ndata.full$cabin_class_first <- cabin_class_first\ndata.full$cabin_class_second <- cabin_class_second\n\n# 生データからいらない変数は除去\ndata.full <- data.full %>% select(-Name, -Ticket) %>% as.data.frame()\n# カテゴリカル変数の欠損には\"unknown\"を入れておく\nfor(i in 1 : ncol(data.full)){\n  class.col <- class(data.full[, i])\n  print(paste(i, class.col))\n  switch (class.col,\n    \"numeric\" = {data.full[is.na(data.full[, i]), i] <- -9999}\n    ,\"integer\" = {data.full[is.na(data.full[, i]), i] <- -9999}\n    ,\"character\" = {\n      data.full[data.full[, i]==\"\" | is.na(data.full[, i]), i] <- \"unknown\"\n      data.full[, i] <- data.full[, i] %>% as.factor()\n    }\n    ,\"factor\" = {\n      data.full[, i] <- data.full[, i] %>% as.character()\n      data.full[data.full[, i]==\"\" | is.na(data.full[, i]), i] <- \"unknown\"\n      data.full[, i] <- data.full[, i] %>% as.factor()\n    }\n  )\n}\n# one hot encoding\ndata.full.s.m.m <- sparse.model.matrix(Survived~.-1, data = data.full)\n# xgbに対応できるようにデータの型変換\ndata.full.xgbD <- xgb.DMatrix(data = data.full.s.m.m, missing = -9999, label = data.full$Survived)\n# train, testにデータを分割する\ntrain.xgbD <- slice(data.full.xgbD, 1:n.train)\ntest.xgbD <- slice(data.full.xgbD, (n.train+1):(n.train+n.test))\n\n# モデリング----\n# 事前設定パラメータ\ncv.nrounds <- 10\ncv.nfold <- 10\ncv.stopping <- 10\n# ハイパーパラメーター\nhyperparamerters <- expand.grid(\n  eta = seq(0.01, 0.5, by = 0.01),\n  min_child_weight = seq(1, 1.1, by = 0.3),\n  max_depth = seq(5, 15, by = 3),\n  max_delta_step = seq(0, 0.2, by = 0.3),\n  gamma = seq(0, 0.2, by = 0.3), \n  subsample = seq(1, 1.1, by = 0.3),\n  colsample_bytree = seq(1, 1.1, by = 0.3)\n)\nn.hyper <- nrow(hyperparamerters)\nv.hyper <- vector(length = n.hyper)\n# プログレスバー\npb <- txtProgressBar(min = 1, max = n.hyper, style = 3)\nfor(i in 1 : n.hyper){\n  setTxtProgressBar(pb, i) \n  param <- list(objective = \"binary:logistic\",\n                eval_metric = \"auc\",\n                max_depth = hyperparamerters$max_depth[i],\n                eta = hyperparamerters$eta[i],\n                gamma = hyperparamerters$gamma[i], \n                subsample = hyperparamerters$subsample[i],\n                colsample_bytree = hyperparamerters$colsample_bytree[i], \n                min_child_weight = hyperparamerters$min_child_weight[i],\n                max_delta_step = hyperparamerters$max_delta_step[i]\n  )\n  tmp.trained.model <- xgb.cv(data = train.xgbD, missing = -9999, nrounds = cv.nrounds\n                              , params = param, nfold = cv.nfold, early.stop.round = cv.stopping, verbose = F)\n  tmp.auc <- tmp.trained.model %>% summarise(max = max(test.auc.mean))\n  v.hyper[i] <- tmp.auc %>% as.numeric()\n}\nbest.hyper <- which.max(v.hyper)\nparam <- list(objective = \"binary:logistic\",\n              eval_metric = \"auc\",\n              max_depth = hyperparamerters$max_depth[best.hyper],\n              eta = hyperparamerters$eta[best.hyper],\n              gamma = hyperparamerters$gamma[best.hyper], \n              subsample = hyperparamerters$subsample[best.hyper],\n              colsample_bytree = hyperparamerters$colsample_bytree[best.hyper], \n              min_child_weight = hyperparamerters$min_child_weight[best.hyper],\n              max_delta_step = hyperparamerters$max_delta_step[best.hyper]\n)\ntrained.model <- xgboost(data = train.xgbD, missing = -9999, nrounds = cv.nrounds\n                         , params = param, nfold = cv.nfold, verbose = F, prediction = T)\nprediction.value <- predict(object = trained.model, test.xgbD)\npredition.01 <- ifelse(test = prediction.value > 0.5, 1, 0)\nprediction.test <- data.frame(PassengerId = data.test.raw$PassengerId, Survived = predition.01)\nwrite.csv(prediction.test, file = \"prediction.csv\", row.names = F)\n\n# 後処理----\n# importance\nimportance <- xgb.importance(data.full.s.m.m@Dimnames[[2]], model = trained.model)\nxgb.plot.importance(importance_matrix = importance)\n\n",
    "created" : 1477780456603.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2934889008",
    "id" : "6CF6058",
    "lastKnownWriteTime" : 1477830598,
    "last_content_update" : 1477830598115,
    "path" : "~/Projects/kaggle/titanic/01_feauture_engineering.R",
    "project_path" : "01_feauture_engineering.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}